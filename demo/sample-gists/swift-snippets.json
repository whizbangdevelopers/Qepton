{
  "description": "Swift Modern Patterns #swift #ios",
  "public": true,
  "files": {
    "ResultBuilder.swift": {
      "content": "import Foundation\n\n/// A result builder for creating HTML-like structures.\n@resultBuilder\nstruct HTMLBuilder {\n    static func buildBlock(_ components: String...) -> String {\n        components.joined(separator: \"\\n\")\n    }\n    \n    static func buildOptional(_ component: String?) -> String {\n        component ?? \"\"\n    }\n    \n    static func buildEither(first component: String) -> String {\n        component\n    }\n    \n    static func buildEither(second component: String) -> String {\n        component\n    }\n    \n    static func buildArray(_ components: [String]) -> String {\n        components.joined(separator: \"\\n\")\n    }\n}\n\nfunc tag(_ name: String, @HTMLBuilder content: () -> String) -> String {\n    \"<\\(name)>\\n\\(content())\\n</\\(name)>\"\n}\n\nfunc text(_ value: String) -> String { value }\n\n// Usage\nlet html = tag(\"div\") {\n    tag(\"h1\") {\n        text(\"Hello, World!\")\n    }\n    tag(\"p\") {\n        text(\"This is a paragraph.\")\n    }\n    for i in 1...3 {\n        tag(\"span\") {\n            text(\"Item \\(i)\")\n        }\n    }\n}\nprint(html)"
    },
    "AsyncHelpers.swift": {
      "content": "import Foundation\n\n/// Async/await utilities for Swift concurrency.\n\n// Retry with exponential backoff\nfunc retry<T>(\n    maxAttempts: Int = 3,\n    initialDelay: TimeInterval = 1.0,\n    maxDelay: TimeInterval = 10.0,\n    factor: Double = 2.0,\n    operation: @Sendable () async throws -> T\n) async throws -> T {\n    var delay = initialDelay\n    \n    for attempt in 1...maxAttempts {\n        do {\n            return try await operation()\n        } catch {\n            if attempt == maxAttempts {\n                throw error\n            }\n            print(\"Attempt \\(attempt) failed, retrying in \\(delay)s...\")\n            try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n            delay = min(delay * factor, maxDelay)\n        }\n    }\n    fatalError(\"Unreachable\")\n}\n\n// Run multiple async operations with a concurrency limit\nfunc mapConcurrently<T, R>(\n    _ items: [T],\n    maxConcurrency: Int = 4,\n    transform: @Sendable @escaping (T) async throws -> R\n) async throws -> [R] {\n    try await withThrowingTaskGroup(of: (Int, R).self) { group in\n        var results = [R?](repeating: nil, count: items.count)\n        var index = 0\n        \n        for (i, item) in items.enumerated() {\n            if index >= maxConcurrency {\n                if let (idx, result) = try await group.next() {\n                    results[idx] = result\n                }\n            }\n            group.addTask {\n                (i, try await transform(item))\n            }\n            index += 1\n        }\n        \n        for try await (idx, result) in group {\n            results[idx] = result\n        }\n        \n        return results.compactMap { $0 }\n    }\n}"
    }
  }
}
