{
  "description": "Java Utility Classes #java #utilities",
  "public": true,
  "files": {
    "StringUtils.java": {
      "content": "package com.example.utils;\n\nimport java.util.Objects;\n\n/**\n * Common string utility methods.\n */\npublic final class StringUtils {\n\n    private StringUtils() {\n        // Utility class, prevent instantiation\n    }\n\n    /**\n     * Check if a string is null or empty.\n     */\n    public static boolean isEmpty(String str) {\n        return str == null || str.isEmpty();\n    }\n\n    /**\n     * Check if a string is null, empty, or contains only whitespace.\n     */\n    public static boolean isBlank(String str) {\n        return str == null || str.trim().isEmpty();\n    }\n\n    /**\n     * Capitalize the first letter of a string.\n     */\n    public static String capitalize(String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        return Character.toUpperCase(str.charAt(0)) + str.substring(1);\n    }\n\n    /**\n     * Truncate a string to the specified length with ellipsis.\n     */\n    public static String truncate(String str, int maxLength) {\n        Objects.requireNonNull(str, \"String cannot be null\");\n        if (maxLength < 3) {\n            throw new IllegalArgumentException(\"Max length must be at least 3\");\n        }\n        if (str.length() <= maxLength) {\n            return str;\n        }\n        return str.substring(0, maxLength - 3) + \"...\";\n    }\n}"
    },
    "Result.java": {
      "content": "package com.example.utils;\n\nimport java.util.Optional;\nimport java.util.function.Function;\n\n/**\n * A Result type for functional error handling (similar to Rust's Result).\n *\n * @param <T> The success value type\n * @param <E> The error type\n */\npublic sealed interface Result<T, E> {\n\n    record Ok<T, E>(T value) implements Result<T, E> {}\n    record Err<T, E>(E error) implements Result<T, E> {}\n\n    static <T, E> Result<T, E> ok(T value) {\n        return new Ok<>(value);\n    }\n\n    static <T, E> Result<T, E> err(E error) {\n        return new Err<>(error);\n    }\n\n    default boolean isOk() {\n        return this instanceof Ok;\n    }\n\n    default boolean isErr() {\n        return this instanceof Err;\n    }\n\n    default Optional<T> ok() {\n        return this instanceof Ok<T, E> ok ? Optional.of(ok.value) : Optional.empty();\n    }\n\n    default <U> Result<U, E> map(Function<T, U> mapper) {\n        return switch (this) {\n            case Ok<T, E> ok -> Result.ok(mapper.apply(ok.value));\n            case Err<T, E> err -> Result.err(err.error);\n        };\n    }\n}"
    }
  }
}
