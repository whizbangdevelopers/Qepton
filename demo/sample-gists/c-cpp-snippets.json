{
  "description": "C/C++ Code Snippets #c #cpp #systems",
  "public": true,
  "files": {
    "safe_array.h": {
      "content": "#ifndef SAFE_ARRAY_H\n#define SAFE_ARRAY_H\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * A bounds-checked dynamic array implementation in C.\n */\ntypedef struct {\n    void *data;\n    size_t size;\n    size_t capacity;\n    size_t element_size;\n} SafeArray;\n\nstatic inline SafeArray* safe_array_create(size_t element_size, size_t initial_capacity) {\n    SafeArray *arr = malloc(sizeof(SafeArray));\n    if (!arr) return NULL;\n    \n    arr->data = malloc(element_size * initial_capacity);\n    if (!arr->data) {\n        free(arr);\n        return NULL;\n    }\n    \n    arr->size = 0;\n    arr->capacity = initial_capacity;\n    arr->element_size = element_size;\n    return arr;\n}\n\nstatic inline int safe_array_push(SafeArray *arr, const void *element) {\n    if (arr->size >= arr->capacity) {\n        size_t new_capacity = arr->capacity * 2;\n        void *new_data = realloc(arr->data, arr->element_size * new_capacity);\n        if (!new_data) return -1;\n        arr->data = new_data;\n        arr->capacity = new_capacity;\n    }\n    \n    memcpy((char*)arr->data + (arr->size * arr->element_size), \n           element, arr->element_size);\n    arr->size++;\n    return 0;\n}\n\nstatic inline void safe_array_free(SafeArray *arr) {\n    if (arr) {\n        free(arr->data);\n        free(arr);\n    }\n}\n\n#endif // SAFE_ARRAY_H"
    },
    "smart_ptr.cpp": {
      "content": "#include <iostream>\n#include <memory>\n#include <vector>\n\n/**\n * Modern C++ smart pointer examples.\n */\n\n// RAII wrapper for a resource\nclass Resource {\npublic:\n    Resource(int id) : id_(id) {\n        std::cout << \"Resource \" << id_ << \" acquired\\n\";\n    }\n    \n    ~Resource() {\n        std::cout << \"Resource \" << id_ << \" released\\n\";\n    }\n    \n    void use() const {\n        std::cout << \"Using resource \" << id_ << \"\\n\";\n    }\n    \nprivate:\n    int id_;\n};\n\nint main() {\n    // unique_ptr - exclusive ownership\n    {\n        auto unique = std::make_unique<Resource>(1);\n        unique->use();\n    } // Resource automatically released\n    \n    // shared_ptr - shared ownership\n    {\n        auto shared1 = std::make_shared<Resource>(2);\n        {\n            auto shared2 = shared1; // ref count = 2\n            shared2->use();\n        } // ref count = 1\n        shared1->use();\n    } // ref count = 0, released\n    \n    // Vector of smart pointers\n    std::vector<std::unique_ptr<Resource>> resources;\n    resources.push_back(std::make_unique<Resource>(3));\n    resources.push_back(std::make_unique<Resource>(4));\n    \n    for (const auto& r : resources) {\n        r->use();\n    }\n    \n    return 0;\n}"
    }
  }
}
