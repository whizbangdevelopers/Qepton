{
  "description": "PHP Modern Practices #php #utilities",
  "public": true,
  "files": {
    "Collection.php": {
      "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Support;\n\n/**\n * A fluent collection wrapper for arrays.\n *\n * @template T\n */\nclass Collection implements \\Countable, \\IteratorAggregate\n{\n    /** @var array<T> */\n    private array $items;\n\n    /**\n     * @param array<T> $items\n     */\n    public function __construct(array $items = [])\n    {\n        $this->items = $items;\n    }\n\n    /**\n     * @template U\n     * @param callable(T): U $callback\n     * @return Collection<U>\n     */\n    public function map(callable $callback): self\n    {\n        return new self(array_map($callback, $this->items));\n    }\n\n    /**\n     * @param callable(T): bool $callback\n     * @return Collection<T>\n     */\n    public function filter(callable $callback): self\n    {\n        return new self(array_values(array_filter($this->items, $callback)));\n    }\n\n    /**\n     * @template U\n     * @param callable(U, T): U $callback\n     * @param U $initial\n     * @return U\n     */\n    public function reduce(callable $callback, mixed $initial): mixed\n    {\n        return array_reduce($this->items, $callback, $initial);\n    }\n\n    public function first(): mixed\n    {\n        return $this->items[0] ?? null;\n    }\n\n    public function count(): int\n    {\n        return count($this->items);\n    }\n\n    public function getIterator(): \\Traversable\n    {\n        return new \\ArrayIterator($this->items);\n    }\n\n    public function toArray(): array\n    {\n        return $this->items;\n    }\n}"
    },
    "validation.php": {
      "content": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Validation;\n\n/**\n * Simple validation helpers using PHP 8 attributes.\n */\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nclass Required\n{\n    public function __construct(\n        public string $message = 'This field is required'\n    ) {}\n}\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nclass Email\n{\n    public function __construct(\n        public string $message = 'Invalid email format'\n    ) {}\n}\n\n#[\\Attribute(\\Attribute::TARGET_PROPERTY)]\nclass MinLength\n{\n    public function __construct(\n        public int $length,\n        public string $message = 'Value is too short'\n    ) {}\n}\n\n// Usage example:\nclass UserDTO\n{\n    #[Required]\n    #[Email]\n    public string $email;\n\n    #[Required]\n    #[MinLength(8, 'Password must be at least 8 characters')]\n    public string $password;\n}\n\n// Validator would use reflection to check attributes\nfunction validate(object $dto): array\n{\n    $errors = [];\n    $reflection = new \\ReflectionClass($dto);\n    \n    foreach ($reflection->getProperties() as $property) {\n        $value = $property->getValue($dto);\n        \n        foreach ($property->getAttributes() as $attribute) {\n            $instance = $attribute->newInstance();\n            // Validation logic here...\n        }\n    }\n    \n    return $errors;\n}"
    }
  }
}
